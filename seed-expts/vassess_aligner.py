#!/usr/bin/env python3

"""
vassess_aligner.py

Given:
 1. a file containing aligner commands
 2. a FASTQ file generated by vassess_reads.py
 3. an index prefix

Run each of the aligner commands on the FASTQ file, using the given index,
and measure how close the aligner came to the true values of AS:i and
XS:i.  Statistics are collected at two levels of granularity: per-read
(third argument) and per-command (fourth argument).
"""

import os
import sys
import subprocess
import time
import numpy as np
import tempfile
import shutil
from collections import defaultdict
from subprocess import PIPE


def flush_command_data(cmd_name, elapsed, cmd_summary_fh, per_read_summary, print_header=False):
    assert len(per_read_summary) > 0
    assert len(per_read_summary[0]) == 4
    if print_header:
        cmd_summary_fh.write('command,elapsed,statistic,mean,med,max,min\n')
    for coli, colname in enumerate(['as_diff_mean', 'xs_diff_mean', 'n_unal', 'n_xs']):
        column = [row[coli] for row in per_read_summary]
        column.sort()
        col_min, col_med, col_max, col_mean = column[0], column[len(column)/2], column[-1], np.mean(column)
        cmd_summary_fh.write(','.join(map(str, [cmd_name, elapsed, colname, col_mean, col_med, col_max, col_min])) + '\n')


def flush_read_data(cmd_name, read_name, read_buffer, per_read_summary_fh, per_read_summary):
    n_unal, n_xs = 0, 0
    ass, xss = [], []
    for asi, xsi in read_buffer:
        if asi is None and xsi is None:
            n_unal += 1
        else:
            if xsi is not None:
                xss.append(xsi)
            else:
                n_xs += 1
            if asi is not None:
                ass.append(asi)
    as_min, as_med, as_max, as_mean = -1, -1, -1, -1
    if len(ass) > 0:
        ass.sort()
        as_min, as_med, as_max, as_mean = ass[0], ass[len(ass)/2], ass[-1], np.mean(ass)
    xs_min, xs_med, xs_max, xs_mean = -1, -1, -1, -1
    if len(xss) > 0:
        xss.sort()
        xs_min, xs_med, xs_max, xs_mean = xss[0], xss[len(xss)/2], xss[-1], np.mean(xss)
    record = list(map(str, [cmd_name, read_name, as_mean, xs_mean,
                            n_unal, n_xs, as_min, as_med, as_max, xs_min, xs_med, xs_max]))
    per_read_summary.append([as_mean, xs_mean, n_unal, n_xs])
    per_read_summary_fh.write(','.join(record) + '\n')


def go(cmds, reads_fn, index_fn, read_summary_fn, cmd_summary_fn):
    with open(read_summary_fn, 'wt') as read_summ_fh:
        with open(cmd_summary_fn, 'wt') as cmd_summary_fh:
            first = True
            for cmd in cmds:
                if cmd[0] == '#':
                    continue
                if len(cmd.strip()) == 0:
                    continue
                cmd_tokens = cmd.rstrip().split()
                cmd_name, cmd = cmd_tokens[0], ' '.join(cmd_tokens[1:])
                tmpdir = tempfile.mkdtemp()
                cmd += ' %s -x %s -S %s/tmp.sam' % (reads_fn, index_fn, tmpdir)
                print('Trying "%s" command "%s"...' % (cmd_name, cmd), file=sys.stderr)
                time_i = time.time()
                os.system(cmd)
                elapsed = time.time() - time_i
                read_buffer, per_read_summary = [], []
                last_read_name = None
                with open('%s/tmp.sam' % tmpdir, 'rt') as fh:
                    for ln in fh:
                        if ln[0] == '@':
                            continue
                        tokens = ln.rstrip().split('\t')
                        name = tokens[0]
                        name_tokens = name.split(':')
                        if last_read_name is None:
                            last_read_name = name_tokens[0]
                        if name_tokens[0] != last_read_name:
                            flush_read_data(cmd_name, last_read_name, read_buffer, read_summ_fh, per_read_summary)
                            read_buffer = []
                            last_read_name = name_tokens[0]
                        assert len(name_tokens) >= 3
                        asi_best, xsi_best, trial = int(name_tokens[-3]), int(name_tokens[-2]), name_tokens[-1]
                        flags = int(tokens[1])
                        if flags & 4 != 0:
                            read_buffer.append((None, None))
                        else:
                            asi, xsi = None, None
                            for tok in tokens[11:]:
                                if tok[:5] == 'AS:i:':
                                    asi = int(tok[5:])
                                if tok[:5] == 'XS:i:':
                                    xsi = int(tok[5:])
                                if asi is not None and xsi is not None:
                                    break
                            if asi is not None and xsi is not None:
                                read_buffer.append((asi_best - asi, xsi_best - xsi))
                            elif asi is not None:
                                read_buffer.append((asi_best - asi, None))
                            else:
                                raise RuntimeError('No AS:i or XS:i for aligned read: ' + ln)
                shutil.rmtree(tmpdir)
                assert not os.path.exists('tmp.sam')
                if len(read_buffer) > 0:
                    flush_read_data(cmd_name, last_read_name, read_buffer, read_summ_fh, per_read_summary)
                flush_command_data(cmd_name, elapsed, cmd_summary_fh, per_read_summary, first)
                first = False


if __name__ == '__main__':
    if len(sys.argv) < 6:
        raise ValueError('Expected arguments: '
                         '(1) File with aligner commands, '
                         '(2) Reads file, '
                         '(3) Index file, '
                         '(4) Read summary output filename, '
                         '(5) Command summary output filename')
    with open(sys.argv[1]) as fh_:
        go(fh_.readlines(), sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])
